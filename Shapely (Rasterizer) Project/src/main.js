/* globals __DEV__ */

// Import bootstrap's contents for webpack (not used below)
// These lines simply ensure that bootstrap is placed in the bundle files
// that are generated by webpack so we don't have to link them separately
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'

// Import jQuery as the usual '$' variable
import $ from 'jquery'

// Import the Program class from the nano-gl library
import Program from 'nanogl/program'

// Import our own Shape and Interface objects
import Shape from './objects/Shape'
import Interface from './interface'
import Point from './objects/Point'
import Color from './objects/Color'
import Triangle from './objects/Triangle'

// Import functions from matrix_math and utils
import { orthoMatrix } from './matrix_math'
import { getWebGLContext, resizeCanvasToDisplaySize } from './utils'

// Global variables shared by many of the functions below
// NOTE: These are only accessible in this one file!!
let gl = null // WebGL rendering context
let rast = null // Canvas rendering context

let shader = null // Compiled shader program
let scene = null // Array of shapes in the scene
let pixels = [] // Queue of pixels to add to the scene
let projM = null // The projection matrix (2d, orthographic)

/**
 * Function to run when page is fully loaded
 */
$(document).ready(() => {
  // Handle a lost webgl context
  let canvas = document.getElementById('glCanvas')
  canvas.addEventListener('webglcontextlost', (event) => {
    event.preventDefault()
  }, false)

  // Respond when our webgl context gets restored
  canvas.addEventListener('webglcontextrestored', initializeWebGL, false)

  // Setup initial webgl context
  initializeWebGL()

  // Setup the GUI event system (must be called once when the document is ready)
  // Note: Imported from interface.js
  Interface.initialize()
})

/**
 * Initialize WebGL for use later in the code. This runs when the document
 * is ready or whenever the WebGL context is restored after being lost.
 */
function initializeWebGL () {
  // Get a WebGL rendering context for the OpenGL canvas element
  gl = getWebGLContext($('#glCanvas')[0], {
    preserveDrawingBuffer: true,
    antialias: true,
    depth: false
  })

  // Set the clear color to black and opaque
  gl.clearColor(0.0, 0.0, 0.0, 1.0)

  // Get a Canvas 2D context and setup for basic rendering
  let rastCanvas = $('#rasterizerCanvas')[0]
  rast = rastCanvas.getContext('2d')
  rastCanvas.width = rastCanvas.clientWidth
  rastCanvas.height = rastCanvas.clientHeight

  // Clear rasterization canvas
  rast.fillStyle = 'black'
  rast.fillRect(0, 0, rastCanvas.width, rastCanvas.height)

  // Create a new shader program and compile and bind our shaders
  shader = new Program(gl, $('#vs').text(), $('#fs').text())
  shader.bind()

  // Allocate/Clear the scene array object
  scene = []

  // Pass references to the rendering context and scene into
  // the Interface object (it will need them later)
  Interface.gl = gl
  Interface.scene = scene

  // let points = []
  // for (let y = 200; y < 600; y += 100) {
  //   for (let x = 200; x < 600; x += 100) {
  //     points.push(new Point(x, y))
  //   }
  // }
  //
  // let tri = new Triangle(gl, points[0], points[1], points[4], Color.GREEN, true)
  // tri.rasterize()
  // scene.push(tri)
  //
  // tri = new Triangle(gl, points[2], points[3], points[7], Color.GREEN, true)
  // tri.rasterize()
  // scene.push(tri)
  //
  // tri = new Triangle(gl, points[8], points[12], points[13], Color.GREEN, true)
  // tri.rasterize()
  // scene.push(tri)
  //
  // tri = new Triangle(gl, points[14], points[15], points[11], Color.GREEN, true)
  // tri.rasterize()
  // scene.push(tri)

  // Start / Restart the rendering loop
  requestAnimationFrame(checkRender)
}

// Queue a pixel for being drawn next time the scene is rasterized
export function setPixel (P, C) {
  pixels.push({
    point: P,
    color: C
  })
}

/**
 * Check if the window/display size has changed and
 * resize the canvas accordingly.
 */
function resizeGLCanvas () {
  // Check window size and resize canvas if needed
  if (resizeCanvasToDisplaySize(gl.canvas)) {
    // Canvas was resized so update the viewport
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

    if (__DEV__) {
      // Print the two resolutions to the console to help debugging
      console.info('Canvas: ' + gl.canvas.width + ' x ' + gl.canvas.height)
      console.info('Buffer: ' + gl.drawingBufferWidth + ' x ' + gl.drawingBufferHeight)
    }

    // Update the projeciton matrix to account for the new canvas dimensions
    projM = orthoMatrix(0, gl.canvas.height - 1, 0, gl.canvas.width - 1)

    // Indicate that the viewport & canvas were resized
    return true
  }

  // Indicate that the viewport & canvas were NOT resized
  return false
}

// Check if the canvas element size has changed and resize GL accordingly
function resizeRastCanvas () {
  if (rast.canvas.width !== rast.canvas.clientWidth ||
      rast.canvas.height !== rast.canvas.clientHeight) {
    rast.canvas.width = rast.canvas.clientWidth
    rast.canvas.height = rast.canvas.clientHeight
    return true
  }

  return false
}

/**
 * Check if the canvas needs a resize or the interface has requested a scene update
 * and render the scene if needed. This function is called continuously as part of
 * the rendering loop.
 */
function checkRender (time) {
  // Rasterizer mode
  if (Interface.rasterizerMode) {
    if (resizeRastCanvas() || Interface.rastUpdateRequested) {
      // If we resized (or re-rast is requested), must redraw entire scene
      redrawSceneRast()
      Interface.rastUpdateRequested = false
    } else if (pixels.length > 0) {
      // Otherwise, only draw if there are pixels in the queue
      renderSceneRast(time)
    }
  } else {
    // Does canvas need a resize? or is an updated needed?
    if (resizeGLCanvas() || Interface.glUpdateRequested) {
      // If so reset the update request and render the scene
      Interface.glUpdateRequested = false
      renderSceneGL(time)
    }
  }

  // Repeat infinitely at a reasonable framerate
  requestAnimationFrame(checkRender)
}

/**
 * Draw all the shapes in the scene array
 */
function renderSceneGL (time) {
  // Clear the screen to black (colors only)
  gl.clear(gl.COLOR_BUFFER_BIT)

  // Use the pre-compiled shader
  shader.use()

  // Call renderShape for each shape
  scene.forEach(renderShapeGL)
}

/**
 * Draw a single shape using WebGL
 */
function renderShapeGL (shape, index) {
  // Pass this shape's properties into the shader
  shape.color.passToShader(shader)
  shader.uProjection(projM)

  // Bind the position attribute to this shape's vertex buffer
  shape.buffer.attribPointer(shader)

  // Draw the shape (or rather, its vertex buffer)
  if (!shape.filled && shape.type !== Shape.SHAPE_TYPE.LINE) {
    // Shape outlines (except lines) are always drawn as a 'line loop'
    shape.buffer.drawLineLoop()
  } else {
    // Draw filled shapes
    switch (shape.type) {
      // Filled circles are drawn as 'triangle fans'
      case Shape.SHAPE_TYPE.CIRCLE:
        shape.buffer.drawTriangleFan()
        break

      // Lines are alwasy drawn as 'lines' (duh)
      case Shape.SHAPE_TYPE.LINE:
        shape.buffer.drawLines()
        break

      // Filled triangles are drawn as 'triangles' (also duh)
      case Shape.SHAPE_TYPE.TRIANGLE:
        shape.buffer.drawTriangles()
        break
    }
  }
}

function redrawSceneRast () {
  // Clear the canvas
  rast.fillStyle = 'black'
  rast.fillRect(0, 0, rast.canvas.width, rast.canvas.height)

  // Generate all pixels by re-rasterizing all shapes
  for (var i = 0; i < scene.length; i++) {
    scene[i].rasterize()
  }

  // Need the latest bounding rect to be able to invert Y
  var rect = rast.canvas.getBoundingClientRect()

  // Immediately render all the gathered pixels
  while (pixels.length > 0) {
    rasterizePixel(
      pixels[0].point.x,
      rect.height - pixels[0].point.y,
      pixels[0].color.css
    )
    pixels.shift()
  }
}

function renderSceneRast (time) {
  // Need the latest bounding rect to be able to invert Y
  var rect = rast.canvas.getBoundingClientRect()

  // Render the gathered pixels up to the speed
  var slowMoCounter = Interface.slowMoSpeed * 5
  while (pixels.length > 0 && (!Interface.slowMoEnabled || slowMoCounter > 0)) {
    rasterizePixel(
      pixels[0].point.x,
      rect.height - pixels[0].point.y,
      pixels[0].color.css
    )
    pixels.shift(); slowMoCounter--
  }
}

function rasterizePixel (x, y, color) {
  rast.fillStyle = color
  rast.fillRect(x, y, 1, 1)
}
